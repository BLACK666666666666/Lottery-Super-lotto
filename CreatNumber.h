#pragma once
#include<time.h>
#include"DateStruct.h"
#include<Windows.h>
#include<math.h>
/*这个定时函数是包裹在循环里面的，非阻塞
*
* 扩展想法
* 1.递归函数本身是阻塞式的，但是可以将出口条件加一条时间限制，限制递归的深度
* 2.递归函数调用时阻是塞式（第一次函数调用时外部无递归环境）
* 3.如果递归函数本身所在为递归环境（第一次函数调用时外部是递归环境）的情况
* 4.循环之中1.非阻塞定时执行任务，2.阻塞执行定时任务，3.条件触发执行指定任务
*/


/*注意-----阻塞和非阻塞是相对于线程说的，在a调用时非阻塞，在b线程执行时就可能是阻塞
循环中非阻塞等待，阻塞式执行任务。定时执行指定任务的函数设计
 1--------------------------------------------------------------------------非线程方法实现
在循环中定时重置随机数种子实现
设计一个非阻塞的定时函数，循环中执行定时任务
解决方案1:参数1是循环开启时的系统时钟，参数二是设置每隔几秒执行，到时间就返回True/False，每几秒返回一次ture（注意返回true满足条件范围后只执行一次，可能会在范围内执行多次，需要处理这种情况）,期间一直返回False，执行代码段（定时任务放在函数外层执行）函数外层是循环环境
解决方案2:参数1是循环开启时的系统时钟，参数二是设置每隔几秒执行，到时间就执行具体任务一次（定时任务放在函数内执行）函数外层是循环环境，定时任务放在函数内执行这种情况参数可以传任务函数的指针，写个回调函数
 2--------------------------------------------------------------------------线程方法实现（实际对于当前调用线程来说是非阻塞等待，非阻塞式执行任务，对于函数所在线程就是非阻塞等待，阻塞式执行任务）
*/
int NonBlockingWaitSetClockReturnTure(DWORD start, unsigned int second);
//检查前区是否有相同的数
int CheakEuqalFront(DatePoint p);
//检查后区是否有相同的数
int CheakEuqalBack(DatePoint p);
//初始化全部置为0
void initNumber(DatePoint p);
//对前区，后区排序
void Sort(DatePoint p);
//用随机数求余生成一个范围的随机值
/*
* 1.以时间做种子生成不同序列的数，但是时间每秒才更新，循环生成大量随机数种子时，循环执行只需ms,所以全是相同的随机数组（播种和随机数生成在同一个函数，而这个函数被循环多次调用，因为每次调用播种为时间0了），除非在函数外播种，不同停调用生成函数
* 2.srand（1），rand（2）.......会生成不同的一串固定序列的数，重启电脑后srand(1)与重启前的srand(1)序列也会不同
*/
void CreatNumber(DatePoint p);

